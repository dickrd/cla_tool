#!/usr/bin/env python
# coding=utf-8
import argparse


def main():
    parser = argparse.ArgumentParser(description='chinese language tools command line.')
    parser.add_argument("action", help="action to perform, including "
                                       "extract, cut, learn, doc2vec, "
                                       "similar, classify, server")
    parser.add_argument("input", nargs="?", help="input for the action")
    parser.add_argument("-o", "--output-file", help="file to save output")
    parser.add_argument("-p", "--port", default=8888, type=int, help="server port to listen")
    parser.add_argument("-m", "--stored-model", help="saved word2vec model")
    parser.add_argument("-t", "--training-data", help="labeled data to train classifier")
    parser.add_argument("-s", "--skip-lines", nargs="+", help="skip lines with the specified prefixes when cutting")
    parser.add_argument("-e", "--encoding", default="utf-8", help="specify file encoding")
    parser.add_argument("--source-type", default="qq", help="source type of the input, supported types are qq")
    args = parser.parse_args()

    if args.action == "extract":
        from cla.util import chat_util
        if not args.input:
            print "Source file is required!"
            return

        print "Prepare extracting sentences from " + args.input
        if args.source_type == "qq":
            result_path = chat_util.process_qq_history(args.input, encoding=args.encoding, output_path=args.output_file)
            print "Done. Extracted sentences saved to " + result_path
        else:
            print "Unsupported type: " + args.source_type

    elif args.action == "cut":
        from cla.util import file_util
        if not args.input:
            print "File contains sentences is required!"
            return

        print "Cutting sentences in " + args.input
        result_path = file_util.cut_words_in(args.input,
                                             encoding=args.encoding,
                                             output_path=args.output_file,
                                             skip_prefixes=args.skip_lines)
        print "Done. Words saved ot " + result_path

    elif args.action == "learn":
        from cla.learn.word2vec import VectorModel
        if not args.input:
            print "File contains words is required!"
            return

        if args.stored_model:
            model = VectorModel(source_file_path=args.stored_model)
            result_file = args.stored_model
            update = True
            print "Loaded previous model: " + args.stored_model
        else:
            result_file = "model.dat"
            model = VectorModel()
            update = False

        print "Learning vector presentation of " + args.input
        model.train(source_corpus_path=args.input, update=update)

        if args.output_file:
            result_file = args.output_file
        model.save(result_file)
        print "Done. Model saved to " + result_file

    elif args.action == "doc2vec":
        from cla.learn.word2vec import VectorModel
        if not args.input:
            print "File contains words is required!"
            return
        if not args.stored_model:
            print "A stored word2vec model is required! (--stored-model)"
            return

        model = VectorModel(source_file_path=args.stored_model)
        if not args.output_file:
            import os
            _, filename = os.path.split(args.input)
            result_path = "vector_of_" + filename
        else:
            result_path = args.output_file

        with open(args.input, 'r') as input_file, open(result_path, 'w') as output_file:
            for line in input_file:
                line = line.decode(encoding=args.encoding).strip()
                if not line:
                    continue

                vector = model.to_vector(line.split(" "))
                output_file.write(" ".join(map(str, vector)) + "\n")
        print "Done. Vectors saved to " + result_path

    elif args.action == "similar":
        from cla.learn.word2vec import VectorModel
        if not args.input:
            print "A input word is required!"
            return
        if not args.stored_model:
            print "A stored word2vec model is required! (--stored-model)"
            return

        model = VectorModel(source_file_path=args.stored_model)
        for word, similarity in model.model.similar_by_word(args.input.decode(args.encoding)):
            print word.encode(args.encoding) + "\t%.5f" % similarity

    elif args.action == "classify":
        from cla.learn.classifier import TraditionalClassifier
        if not args.input:
            print "File contains words is required!"
            return
        if not args.stored_model:
            print "A stored word2vec model is required! (--stored-model)"
            return
        if not args.training_data:
            print "Training labeled data is required! (--training-data)"
            return

        if not args.output_file:
            import os
            _, filename = os.path.split(args.input)
            result_path = "classified_" + filename
        else:
            result_path = args.output_file

        classifier = TraditionalClassifier(vector_model_path=args.stored_model, training_data_path=args.training_data)
        with open(args.input, 'r') as input_file, open(result_path, 'w') as output_file:
            for line in input_file:
                line = line.decode(encoding=args.encoding)
                classified = classifier.classify([line])[0]
                output_file.write(classified + " " + line.encode(encoding=args.encoding) + "\n")

    elif args.action == "server":
        import SocketServer
        from BaseHTTPServer import BaseHTTPRequestHandler

        # noinspection PyPep8Naming,PyClassHasNoInit
        class Handler(BaseHTTPRequestHandler):
            def do_GET(self):
                splits = self.path.split("/")
                self.send_response(200)
                self.send_header("Content-type", "application/json")
                self.end_headers()
                self.wfile.write(splits)

        httpd = SocketServer.TCPServer(("", args.port), Handler)

        print "Serving at port: ", args.port
        httpd.serve_forever()

    else:
        print "Unsupported action: " + args.action

if __name__ == '__main__':
    main()
